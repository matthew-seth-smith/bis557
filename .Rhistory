# treatment to half of the block
coin <- rbinom(1, 1, 0.5) #We take the result of evaluating a binomial random variable one time with
# size 1 and probability of success 0.5, essentially flipping a fair coin
if(coin == 1){ #If heads
block <- c(block, "A") #Concatenate an A to the vector collecting the block
A <- A + 1 #Increase the total count of A's
}else{ #If tails
block <- c(block, "B") #Concatenate a B to the vector containing the block
B <- B + 1 #Increase the total count of B's
}
if(A == floor(block_len/2)){ #If A has won half of the times this iteration; we use a floor function
# in case block_len is odd (which it should not be because we only have two treatment groups)
block[(i+1):block_len] <- "B" #Assign the remaining participants in the block to B so the block is balanced
break #Break the for loop but stay inside the larger while loop
}else if(B == floor(block_len/2)){ #Now we look to see if B has won in this block
block[(i+1):block_len] <- "A" #Assign the remaining participants in the block to B
break #Break the for loop but not the larger while loop
}
# Using the above if() conditions, we should guarantee that this block is balanced
} #Close the for loop for this block
random_scheme <- c(random_scheme, block) #Add this block to the collection of the entire scheme
} #Close the while loop
random_scheme #Return the random_scheme vector
}
# Question 2
# Now we show the function works by calling it on the three given scenarios
permuted(100, c(4,8), 990235)
permuted(240, c(4,6,8,10), 101211)
permuted(120, c(2,4,6), 904523)
# Matthew Smith, 11/13/18
# BIS 679
# Homework 9, due 11/15
# Question 1
# Here we create the permuted function to create a permuted block randomization scheme
# We begin with the documentation for this function
#####################################################################################################
#Function: permuted
#Author: Matthew Smith
#Creation Date: 11/13/18
#Purpose: Create a permuted block randomization scheme for two treatment groups (A and B).
#         The output is a vector of A and B. The sample size does not need to be divisible by the
#         block sizes, so the output vector might be longer than the desired sample size by no more
#         than the largest possible block size. We randomize the block size between blocks.
# Required Parameters:
#      n = the sample size of individuals to randomize
#      block_sizes = a vector of possible block sizes (these do not have to be factors of the total sample size)
# Optional Parameters:
#      seed = the seed to start the random number generator; if not specified it will be a randomly selected
#             number between 1 and 999999999
# Output: A vector of A's and B's corresponding to the two treatment groups
#         Depending on the permutation of the block sizes, this output vector might be longer than the
#         desired sample size n, but this will only be by less than the largest possible block size
# Example: We will create a permuted block randomization scheme for a sample size n of 100, with possible
#          block sizes of 2 and 4 and the seed 1729 (Ramanujan's number):
#          permuted(100, c(2,4), 1729)
#####################################################################################################
permuted <- function(n, block_sizes, seed=sample(99999999,1)){
#We initialize the function and give it the default seed generated randomly between 1 and 99999999
set.seed(seed) #The very first thing we do is set the seed so we can reproduce the results
random_scheme <- NULL #We intialize the output vector of the randomization scheme
while(length(random_scheme) < n){ #We loop the randomization of the block size and only stop once
# we have added enough randomizations for the entire sample size n
block_len <- NULL #Initialize the length of this block
if(length(block_sizes) == 1){ #If there is only one block size given
block_len <- block_sizes #These are atomic values
}else{ #If there is more than one possible block size
block_len <- sample(block_sizes, 1) #We randomly sample from the vector of block sizes to determine how
# big the block in this iteration of the loop should be
}
block <- NULL #Initialize the vector for the block randomization to be contatenated to random_scheme later
# We will achieve balance between assignments A and B within each block by generating a random number
# between 0 and 1 (with the runif function with n=1 for the number of observation) multiple times and
# stopping when one of the assignments reaches half of the block size. We then set all the remaining
# participants to the under-subscribed treatment assignment. This implementation will be an adaptation
# of the coin.toss function and its variations from class
A <- 0 #Initialize the number of A's in this block
B <- 0 #Initialize the number of B's in this block
for(i in 1:block_len){ #Loop over the length of the block, possibly stopping early if we assign one
# treatment to half of the block
coin <- rbinom(1, 1, 0.5) #We take the result of evaluating a binomial random variable one time with
# size 1 and probability of success 0.5, essentially flipping a fair coin
if(coin == 1){ #If heads
block <- c(block, "A") #Concatenate an A to the vector collecting the block
A <- A + 1 #Increase the total count of A's
}else{ #If tails
block <- c(block, "B") #Concatenate a B to the vector containing the block
B <- B + 1 #Increase the total count of B's
}
if(A == floor(block_len/2)){ #If A has won half of the times this iteration; we use a floor function
# in case block_len is odd (which it should not be because we only have two treatment groups)
block[(i+1):block_len] <- "B" #Assign the remaining participants in the block to B so the block is balanced
break #Break the for loop but stay inside the larger while loop
}else if(B == floor(block_len/2)){ #Now we look to see if B has won in this block
block[(i+1):block_len] <- "A" #Assign the remaining participants in the block to B
break #Break the for loop but not the larger while loop
}
# Using the above if() conditions, we should guarantee that this block is balanced
} #Close the for loop for this block
random_scheme <- c(random_scheme, block) #Add this block to the collection of the entire scheme
} #Close the while loop
random_scheme #Return the random_scheme vector
}
# Question 2
# Now we show the function works by calling it on the three given scenarios
permuted(100, c(4,8), 990235)
permuted(240, c(4,6,8,10), 101211)
permuted(120, c(2,4,6), 904523)
# Matthew Smith, 11/13/18
# BIS 679
# Homework 9, due 11/15
# Question 1
# Here we create the permuted function to create a permuted block randomization scheme
# We begin with the documentation for this function
#####################################################################################################
#Function: permuted
#Author: Matthew Smith
#Creation Date: 11/13/18
#Purpose: Create a permuted block randomization scheme for two treatment groups (A and B).
#         The output is a vector of A and B. The sample size does not need to be divisible by the
#         block sizes, so the output vector might be longer than the desired sample size by no more
#         than the largest possible block size. We randomize the block size between blocks.
# Required Parameters:
#      n = the sample size of individuals to randomize
#      block_sizes = a vector of possible block sizes (these do not have to be factors of the total sample size)
# Optional Parameters:
#      seed = the seed to start the random number generator; if not specified it will be a randomly selected
#             number between 1 and 999999999
# Output: A vector of A's and B's corresponding to the two treatment groups
#         Depending on the permutation of the block sizes, this output vector might be longer than the
#         desired sample size n, but this will only be by less than the largest possible block size
# Example: We will create a permuted block randomization scheme for a sample size n of 100, with possible
#          block sizes of 2 and 4 and the seed 1729 (Ramanujan's number):
#          permuted(100, c(2,4), 1729)
#####################################################################################################
permuted <- function(n, block_sizes, seed=sample(99999999,1)){
#We initialize the function and give it the default seed generated randomly between 1 and 99999999
set.seed(seed) #The very first thing we do is set the seed so we can reproduce the results
random_scheme <- NULL #We intialize the output vector of the randomization scheme
while(length(random_scheme) < n){ #We loop the randomization of the block size and only stop once
# we have added enough randomizations for the entire sample size n
block_len <- NULL #Initialize the length of this block
if(length(block_sizes) == 1){ #If there is only one block size given
block_len <- block_sizes #These are atomic values
}else{ #If there is more than one possible block size
block_len <- sample(block_sizes, 1) #We randomly sample from the vector of block sizes to determine how
# big the block in this iteration of the loop should be
}
block <- NULL #Initialize the vector for the block randomization to be contatenated to random_scheme later
# We will achieve balance between assignments A and B within each block by generating a random number
# between 0 and 1 (with the runif function with n=1 for the number of observation) multiple times and
# stopping when one of the assignments reaches half of the block size. We then set all the remaining
# participants to the under-subscribed treatment assignment. This implementation will be an adaptation
# of the coin.toss function and its variations from class
A <- 0 #Initialize the number of A's in this block
B <- 0 #Initialize the number of B's in this block
for(i in 1:block_len){ #Loop over the length of the block, possibly stopping early if we assign one
# treatment to half of the block
coin <- rbinom(1, 1, 0.5) #We take the result of evaluating a binomial random variable one time with
# size 1 and probability of success 0.5, essentially flipping a fair coin
if(coin == 1){ #If heads
block <- c(block, "A") #Concatenate an A to the vector collecting the block
A <- A + 1 #Increase the total count of A's
}else{ #If tails
block <- c(block, "B") #Concatenate a B to the vector containing the block
B <- B + 1 #Increase the total count of B's
}
if(A == floor(block_len/2)){ #If A has won half of the times this iteration; we use a floor function
# in case block_len is odd (which it should not be because we only have two treatment groups)
block[(i+1):block_len] <- "B" #Assign the remaining participants in the block to B so the block is balanced
break #Break the for loop but stay inside the larger while loop
}else if(B == floor(block_len/2)){ #Now we look to see if B has won in this block
block[(i+1):block_len] <- "A" #Assign the remaining participants in the block to B
break #Break the for loop but not the larger while loop
}
# Using the above if() conditions, we should guarantee that this block is balanced
} #Close the for loop for this block
random_scheme <- c(random_scheme, block) #Add this block to the collection of the entire scheme
} #Close the while loop
random_scheme #Return the random_scheme vector
}
# Question 2
# Now we show the function works by calling it on the three given scenarios
permuted(100, c(4,8), 990235)
permuted(240, c(4,6,8,10), 101211)
permuted(120, c(2,4,6), 904523)
# Matthew Smith, 11/13/18
# BIS 679
# Homework 9, due 11/15
# Question 1
# Here we create the permuted function to create a permuted block randomization scheme
# We begin with the documentation for this function
#####################################################################################################
#Function: permuted
#Author: Matthew Smith
#Creation Date: 11/13/18
#Purpose: Create a permuted block randomization scheme for two treatment groups (A and B).
#         The output is a vector of A and B. The sample size does not need to be divisible by the
#         block sizes, so the output vector might be longer than the desired sample size by no more
#         than the largest possible block size. We randomize the block size between blocks.
# Required Parameters:
#      n = the sample size of individuals to randomize
#      block_sizes = a vector of possible block sizes (these do not have to be factors of the total sample size)
# Optional Parameters:
#      seed = the seed to start the random number generator; if not specified it will be a randomly selected
#             number between 1 and 999999999
# Output: A vector of A's and B's corresponding to the two treatment groups
#         Depending on the permutation of the block sizes, this output vector might be longer than the
#         desired sample size n, but this will only be by less than the largest possible block size
# Example: We will create a permuted block randomization scheme for a sample size n of 100, with possible
#          block sizes of 2 and 4 and the seed 1729 (Ramanujan's number):
#          permuted(100, c(2,4), 1729)
#####################################################################################################
permuted <- function(n, block_sizes, seed=sample(99999999,1)){
#We initialize the function and give it the default seed generated randomly between 1 and 99999999
set.seed(seed) #The very first thing we do is set the seed so we can reproduce the results
random_scheme <- NULL #We intialize the output vector of the randomization scheme
while(length(random_scheme) < n){ #We loop the randomization of the block size and only stop once
# we have added enough randomizations for the entire sample size n
block_len <- NULL #Initialize the length of this block
if(length(block_sizes) == 1){ #If there is only one block size given
block_len <- block_sizes #These are atomic values
}else{ #If there is more than one possible block size
block_len <- sample(block_sizes, 1) #We randomly sample from the vector of block sizes to determine how
# big the block in this iteration of the loop should be
}
block <- NULL #Initialize the vector for the block randomization to be contatenated to random_scheme later
# We will achieve balance between assignments A and B within each block by generating a random number
# between 0 and 1 (with the runif function with n=1 for the number of observation) multiple times and
# stopping when one of the assignments reaches half of the block size. We then set all the remaining
# participants to the under-subscribed treatment assignment. This implementation will be an adaptation
# of the coin.toss function and its variations from class
A <- 0 #Initialize the number of A's in this block
B <- 0 #Initialize the number of B's in this block
for(i in 1:block_len){ #Loop over the length of the block, possibly stopping early if we assign one
# treatment to half of the block
coin <- rbinom(1, 1, 0.5) #We take the result of evaluating a binomial random variable one time with
# size 1 and probability of success 0.5, essentially flipping a fair coin
if(coin == 1){ #If heads
block <- c(block, "A") #Concatenate an A to the vector collecting the block
A <- A + 1 #Increase the total count of A's
}else{ #If tails
block <- c(block, "B") #Concatenate a B to the vector containing the block
B <- B + 1 #Increase the total count of B's
}
if(A == floor(block_len/2)){ #If A has won half of the times this iteration; we use a floor function
# in case block_len is odd (which it should not be because we only have two treatment groups)
block[(i+1):block_len] <- "B" #Assign the remaining participants in the block to B so the block is balanced
break #Break the for loop but stay inside the larger while loop
}else if(B == floor(block_len/2)){ #Now we look to see if B has won in this block
block[(i+1):block_len] <- "A" #Assign the remaining participants in the block to B
break #Break the for loop but not the larger while loop
}
# Using the above if() conditions, we should guarantee that this block is balanced
} #Close the for loop for this block
random_scheme <- c(random_scheme, block) #Add this block to the collection of the entire scheme
} #Close the while loop
random_scheme #Return the random_scheme vector
}
# Question 2
# Now we show the function works by calling it on the three given scenarios
permuted(100, c(4,8), 990235)
permuted(240, c(4,6,8,10), 101211)
permuted(120, c(2,4,6), 904523)
rm(permuted)
# Matthew Smith, 11/13/18
# BIS 679
# Homework 9, due 11/15
# Question 1
# Here we create the permuted function to create a permuted block randomization scheme
# We begin with the documentation for this function
#####################################################################################################
#Function: permuted
#Author: Matthew Smith
#Creation Date: 11/13/18
#Purpose: Create a permuted block randomization scheme for two treatment groups (A and B).
#         The output is a vector of A and B. The sample size does not need to be divisible by the
#         block sizes, so the output vector might be longer than the desired sample size by no more
#         than the largest possible block size. We randomize the block size between blocks.
# Required Parameters:
#      n = the sample size of individuals to randomize
#      block_sizes = a vector of possible block sizes (these do not have to be factors of the total sample size)
# Optional Parameters:
#      seed = the seed to start the random number generator; if not specified it will be a randomly selected
#             number between 1 and 999999999
# Output: A vector of A's and B's corresponding to the two treatment groups
#         Depending on the permutation of the block sizes, this output vector might be longer than the
#         desired sample size n, but this will only be by less than the largest possible block size
# Example: We will create a permuted block randomization scheme for a sample size n of 100, with possible
#          block sizes of 2 and 4 and the seed 1729 (Ramanujan's number):
#          permuted(100, c(2,4), 1729)
#####################################################################################################
permuted <- function(n, block_sizes, seed=sample(99999999,1)){
#We initialize the function and give it the default seed generated randomly between 1 and 99999999
set.seed(seed) #The very first thing we do is set the seed so we can reproduce the results
random_scheme <- NULL #We intialize the output vector of the randomization scheme
while(length(random_scheme) < n){ #We loop the randomization of the block size and only stop once
# we have added enough randomizations for the entire sample size n
block_len <- NULL #Initialize the length of this block
if(length(block_sizes) == 1){ #If there is only one block size given
block_len <- block_sizes #These are atomic values
}else{ #If there is more than one possible block size
block_len <- sample(block_sizes, 1) #We randomly sample from the vector of block sizes to determine how
# big the block in this iteration of the loop should be
}
block <- NULL #Initialize the vector for the block randomization to be contatenated to random_scheme later
# We will achieve balance between assignments A and B within each block by generating a random number
# between 0 and 1 (with the runif function with n=1 for the number of observation) multiple times and
# stopping when one of the assignments reaches half of the block size. We then set all the remaining
# participants to the under-subscribed treatment assignment. This implementation will be an adaptation
# of the coin.toss function and its variations from class
A <- 0 #Initialize the number of A's in this block
B <- 0 #Initialize the number of B's in this block
for(i in 1:block_len){ #Loop over the length of the block, possibly stopping early if we assign one
# treatment to half of the block
coin <- rbinom(1, 1, 0.5) #We take the result of evaluating a binomial random variable one time with
# size 1 and probability of success 0.5, essentially flipping a fair coin
if(coin == 1){ #If heads
block <- c(block, "A") #Concatenate an A to the vector collecting the block
A <- A + 1 #Increase the total count of A's
}else{ #If tails
block <- c(block, "B") #Concatenate a B to the vector containing the block
B <- B + 1 #Increase the total count of B's
}
if(A == floor(block_len/2)){ #If A has won half of the times this iteration; we use a floor function
# in case block_len is odd (which it should not be because we only have two treatment groups)
block[(i+1):block_len] <- "B" #Assign the remaining participants in the block to B so the block is balanced
break #Break the for loop but stay inside the larger while loop
}else if(B == floor(block_len/2)){ #Now we look to see if B has won in this block
block[(i+1):block_len] <- "A" #Assign the remaining participants in the block to B
break #Break the for loop but not the larger while loop
}
# Using the above if() conditions, we should guarantee that this block is balanced
} #Close the for loop for this block
random_scheme <- c(random_scheme, block) #Add this block to the collection of the entire scheme
} #Close the while loop
random_scheme #Return the random_scheme vector
}
# Question 2
# Now we show the function works by calling it on the three given scenarios
permuted(100, c(4,8), 990235)
permuted(240, c(4,6,8,10), 101211)
permuted(120, c(2,4,6), 904523)
# Matthew Smith, 11/13/18
# BIS 679
# Homework 9, due 11/15
# Question 1
# Here we create the permuted function to create a permuted block randomization scheme
# We begin with the documentation for this function
#####################################################################################################
#Function: permuted
#Author: Matthew Smith
#Creation Date: 11/13/18
#Purpose: Create a permuted block randomization scheme for two treatment groups (A and B).
#         The output is a vector of A and B. The sample size does not need to be divisible by the
#         block sizes, so the output vector might be longer than the desired sample size by no more
#         than the largest possible block size. We randomize the block size between blocks.
# Required Parameters:
#      n = the sample size of individuals to randomize
#      block_sizes = a vector of possible block sizes (these do not have to be factors of the total sample size)
# Optional Parameters:
#      seed = the seed to start the random number generator; if not specified it will be a randomly selected
#             number between 1 and 999999999
# Output: A vector of A's and B's corresponding to the two treatment groups
#         Depending on the permutation of the block sizes, this output vector might be longer than the
#         desired sample size n, but this will only be by less than the largest possible block size
# Example: We will create a permuted block randomization scheme for a sample size n of 100, with possible
#          block sizes of 2 and 4 and the seed 1729 (Ramanujan's number):
#          permuted(100, c(2,4), 1729)
#####################################################################################################
permuted <- function(n, block_sizes, seed=sample(99999999,1)){
#We initialize the function and give it the default seed generated randomly between 1 and 99999999
set.seed(seed) #The very first thing we do is set the seed so we can reproduce the results
random_scheme <- NULL #We intialize the output vector of the randomization scheme
while(length(random_scheme) < n){ #We loop the randomization of the block size and only stop once
# we have added enough randomizations for the entire sample size n
block_len <- NULL #Initialize the length of this block
if(length(block_sizes) == 1){ #If there is only one block size given
block_len <- block_sizes #These are atomic values
}else{ #If there is more than one possible block size
block_len <- sample(block_sizes, 1) #We randomly sample from the vector of block sizes to determine how
# big the block in this iteration of the loop should be
}
block <- NULL #Initialize the vector for the block randomization to be contatenated to random_scheme later
# We will achieve balance between assignments A and B within each block by generating a random number
# between 0 and 1 (with the runif function with n=1 for the number of observation) multiple times and
# stopping when one of the assignments reaches half of the block size. We then set all the remaining
# participants to the under-subscribed treatment assignment. This implementation will be an adaptation
# of the coin.toss function and its variations from class
A <- 0 #Initialize the number of A's in this block
B <- 0 #Initialize the number of B's in this block
for(i in 1:block_len){ #Loop over the length of the block, possibly stopping early if we assign one
# treatment to half of the block
coin <- rbinom(1, 1, 0.5) #We take the result of evaluating a binomial random variable one time with
# size 1 and probability of success 0.5, essentially flipping a fair coin
if(coin == 1){ #If heads
block <- c(block, "A") #Concatenate an A to the vector collecting the block
A <- A + 1 #Increase the total count of A's
}else{ #If tails
block <- c(block, "B") #Concatenate a B to the vector containing the block
B <- B + 1 #Increase the total count of B's
}
if(A == floor(block_len/2)){ #If A has won half of the times this iteration; we use a floor function
# in case block_len is odd (which it should not be because we only have two treatment groups)
block[(i+1):block_len] <- "B" #Assign the remaining participants in the block to B so the block is balanced
break #Break the for loop but stay inside the larger while loop
}else if(B == floor(block_len/2)){ #Now we look to see if B has won in this block
block[(i+1):block_len] <- "A" #Assign the remaining participants in the block to B
break #Break the for loop but not the larger while loop
}
# Using the above if() conditions, we should guarantee that this block is balanced
} #Close the for loop for this block
random_scheme <- c(random_scheme, block) #Add this block to the collection of the entire scheme
} #Close the while loop
random_scheme #Return the random_scheme vector
}
# Question 2
# Now we show the function works by calling it on the three given scenarios
permuted(100, c(4,8), 990235)
permuted(240, c(4,6,8,10), 101211)
permuted(120, c(2,4,6), 904523)
1+2:3
# Matthew Smith, 11/13/18
# BIS 679
# Homework 9, due 11/15
# Question 1
# Here we create the permuted function to create a permuted block randomization scheme
# We begin with the documentation for this function
#####################################################################################################
#Function: permuted
#Author: Matthew Smith
#Creation Date: 11/13/18
#Purpose: Create a permuted block randomization scheme for two treatment groups (A and B).
#         The output is a vector of A and B. The sample size does not need to be divisible by the
#         block sizes, so the output vector might be longer than the desired sample size by no more
#         than the largest possible block size. We randomize the block size between blocks.
# Required Parameters:
#      n = the sample size of individuals to randomize
#      block_sizes = a vector of possible block sizes (these do not have to be factors of the total sample size)
# Optional Parameters:
#      seed = the seed to start the random number generator; if not specified it will be a randomly selected
#             number between 1 and 999999999
# Output: A vector of A's and B's corresponding to the two treatment groups
#         Depending on the permutation of the block sizes, this output vector might be longer than the
#         desired sample size n, but this will only be by less than the largest possible block size
# Example: We will create a permuted block randomization scheme for a sample size n of 100, with possible
#          block sizes of 2 and 4 and the seed 1729 (Ramanujan's number):
#          permuted(100, c(2,4), 1729)
#####################################################################################################
permuted <- function(n, block_sizes, seed=sample(99999999,1)){
#We initialize the function and give it the default seed generated randomly between 1 and 99999999
set.seed(seed) #The very first thing we do is set the seed so we can reproduce the results
random_scheme <- NULL #We intialize the output vector of the randomization scheme
while(length(random_scheme) < n){ #We loop the randomization of the block size and only stop once
# we have added enough randomizations for the entire sample size n
block_len <- NULL #Initialize the length of this block
if(length(block_sizes) == 1){ #If there is only one block size given
block_len <- block_sizes #These are atomic values
}else{ #If there is more than one possible block size
block_len <- sample(block_sizes, 1) #We randomly sample from the vector of block sizes to determine how
# big the block in this iteration of the loop should be
}
block <- NULL #Initialize the vector for the block randomization to be contatenated to random_scheme later
# We will achieve balance between assignments A and B within each block by generating a random number
# between 0 and 1 (with the runif function with n=1 for the number of observation) multiple times and
# stopping when one of the assignments reaches half of the block size. We then set all the remaining
# participants to the under-subscribed treatment assignment. This implementation will be an adaptation
# of the coin.toss function and its variations from class
A <- 0 #Initialize the number of A's in this block
B <- 0 #Initialize the number of B's in this block
for(i in 1:block_len){ #Loop over the length of the block, possibly stopping early if we assign one
# treatment to half of the block
coin <- rbinom(1, 1, 0.5) #We take the result of evaluating a binomial random variable one time with
# size 1 and probability of success 0.5, essentially flipping a fair coin
if(coin == 1){ #If heads
block <- c(block, "A") #Concatenate an A to the vector collecting the block
A <- A + 1 #Increase the total count of A's
}else{ #If tails
block <- c(block, "B") #Concatenate a B to the vector containing the block
B <- B + 1 #Increase the total count of B's
}
if(A == floor(block_len/2)){ #If A has won half of the times this iteration; we use a floor function
# in case block_len is odd (which it should not be because we only have two treatment groups)
block[(i+1):block_len] <- "B" #Assign the remaining participants in the block to B so the block is balanced
break #Break the for loop but stay inside the larger while loop
}else if(B == floor(block_len/2)){ #Now we look to see if B has won in this block
block[(i+1):block_len] <- "A" #Assign the remaining participants in the block to B
break #Break the for loop but not the larger while loop
}
# Using the above if() conditions, we should guarantee that this block is balanced
} #Close the for loop for this block
random_scheme <- c(random_scheme, block) #Add this block to the collection of the entire scheme
} #Close the while loop
random_scheme #Return the random_scheme vector
}
# Question 2
# Now we show the function works by calling it on the three given scenarios
permuted(100, c(4,8), 990235)
permuted(240, c(4,6,8,10), 101211)
permuted(120, c(2,4,6), 904523)
library(faraway)
data(pima)
?pima
mean(TRUE & TRUE)
library(devtools)
setwd("~/Documents/YSPH/YSPH_Year2/BIS_557/bis557/vignettes")
setwd("~/Documents/YSPH/YSPH_Year2/BIS_557/bis557/")
library(bis557)
build_vignettes()
document()
build_vignettes()
document()
build_vignettes()
