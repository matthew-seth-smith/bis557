plot.coverage(40, p.vector, seed)
# Question 2
plot.coverage(c(10, 20, 30), p.vector, seed)
# Question 3
plot.coverage(seq(10, 80, 10), p.vector, seed)
# This throws an error, as it should, because it has 8 sample sizes
# Question 4
plot.coverage(c(25, 50, 100, 200), p.vector, seed)
plot.coverage(seq(10,60,10), p.vector, seed)
# Question 4
plot.coverage(c(25, 50, 100, 200), p.vector, seed)
p <- plot.coverage(c(25, 50, 100, 200), p.vector, seed)
p
plot(seq(10,60,10), seq(0.01,0.50,0.01), 1998)
plot.coverage(seq(10,60,10), seq(0.01,0.50,0.01), 1998)
rm(list=ls())
# Matthew Smith, 11/28/18
# BIS 679
# Homework 10, due 11/29
# First we include the coverage function from Notes8.R
######################################################################################################
#Function: coverage
#Author: Denise Esserman
#Creation Date: November 24, 2015 (version 3.2.2)
#Modified: November 06, 2017 (version 3.4.2)
#Purpose: This function calculates the coverage probabilities for a one sample proportion using
#         three methods (1) exact, (2) asymptotic, (3) asymptotic with continuity correction
# Required Parameters:
#      n.vector = a vector of the sample sizes that we want to explore
#      p.vector= a vector of probabilities that we want to explore
#      seed = the seed to start the random number generator
#Optional Parameters:
#      nsims=the number of simulations to conduct - default is 1000
#Libraries: Requires the installation of binom package
#Output: Returns an array with the coverage probabilites.  Each matrix within the array
#represents a given sample size in n.vector.  The rows in the matrix are the probabilities we
#want to explore and the columns represent the 3 methods.
#Example: Calculate the coverage probabilities for two sample sizes and 5 proportions
#coverage(n.vector=c(30,100),p.vector=c(0.1,0.2,0.3,0.4,0.5), seed=121212)
########################################################################################################
coverage<-function(n.vector, p.vector, seed, nsims=1000) {
#check to see if the package is already installed
if (!require("binom")) install.packages("binom")
require(binom) #load the package
# First one: check if there
# Second one: check if installed
set.seed(seed)
#nsims=nsims
y=list(p.vector,c("Exact", "Asymptotic", "Continuity Corrected"), n.vector)
cover.prob<-array(rep(NA, length(p.vector)*3*length(n.vector)),dim=c(length(p.vector),3, length(n.vector)),dimnames=y)
for(j in 1:length(n.vector)) {
for(i in 1:length(p.vector)){
#Get vector of length nsims containing the number of successes from the binomial distribution
# with size n and probability of succcess p
successes<-rbinom(nsims,size=n.vector[j],p=p.vector[i])
#Get the upper and lower bounds of each of the three types of confidence intervals
lower.exact<-binom.confint(successes,n.vector[j],method="exact")$lower
upper.exact<-binom.confint(successes,n.vector[j],method="exact")$upper
lower.asym<-binom.confint(successes,n.vector[j],method="asymptotic")$lower
upper.asym<-binom.confint(successes,n.vector[j],method="asymptotic")$upper
lower.cc<-lower.asym-0.5/n.vector[j]
upper.cc<-upper.asym+0.5/n.vector[j]
cover.prob[i,1,j]<-mean(lower.exact<=p.vector[i] & upper.exact>=p.vector[i])
cover.prob[i,2,j]<-mean(lower.asym<=p.vector[i] & upper.asym>=p.vector[i])
cover.prob[i,3,j]<-mean(lower.cc<=p.vector[i] & upper.cc>=p.vector[i])
}
}
return(cover.prob) #return the array
}
# Next we construct the plot.coverage function and document it
######################################################################################################
# Function: plot.coverage
# Author: Matthew Smith
# Creation Date: November 28, 2018
# Purpose: This function uses the coverage function from class to calculate coverage probabilities
#          using exact, asymptotic, and asymptotic with continuity correction methods, for up to
#          6 different sample sizes. The function then plots (for each sample size) the coverage
#          probability for each real probability, for each method of determining the coverage probability,
#          all in one plot window.
# Required Parameters:
#      n.vector = a vector of the sample sizes that we want to explore
#      p.vector = a vector of probabilities that we want to explore
#      seed = the seed to start the random number generator
# Optional Parameters:
#      nsims = the number of simulations to conduct (default is 1000)
# Libraries: Requires the installation of binom package
# Dependent Functions: Requires the coverage function from class to be loaded
# Output: This function does not return a value but instead creates plots in the plot window. There is
#         one plot for each sample size given. On each plot, the real probabilities for the underlying
#         simulations are on the x-axis, and the calculated coverage probabilities (using each of the
#         3 methods) are on the y-axis. All of the plots are in the same window, and the size of the
#         legends depend on the number of plots. The function throws an error if the user supplies more
#         than 6 sample sizes.
# Example: In this example, we create plots for sample sizes 10, 20, 30, 40, 50, and 60, probabilities
#          ranging from 0.01 to 0.50 by 0.01, and seed 1998.
#          plot.coverage(seq(10,60,10), seq(0.01,0.50,0.01), 1998)
########################################################################################################
plot.coverage <- function(n.vector, p.vector, seed, nsims=1000){ #This uses the same parameters as coverage
# First we format the plot window or throw an error if the user enters too many sample sizes
if(length(n.vector) == 1){
par(mfrow=c(1,1)) #If we only have one sample size, format the plot window for one plot
}else if(length(n.vector) <= 6){
par(mfrow=c(2, ceiling(length(n.vector)/2)))
# If we have a sample size between 2 and 6, we format the plot window with two rows
# We use a ceiling function to set the number of columns so that length(n.vector)=2 gives one column,
# length(n.vector) = 3 or 4 gives 2 columns, and length(n.vector) = 5 or 6 gives 3 columns
}else{ #If there are more than six sample sizes
stop("User entered too many sample sizes. Please enter 6 or fewer.") #Message when error thrown
}
# Now we run the coverage function (which will load the binom package), the output of which we will plot
cover <- coverage(n.vector=n.vector, p.vector=p.vector, seed=seed, nsims=nsims) #Use the parameters from plot.coverage
# This is an array, where each matrix corresponds to a sample size n, each row is a probability p, and
# each column is the coverage probability according to a different method of calculating
# There are length(n.vector) matrices, and we will have a different plot
# The probabilities p will be on the x-axis of each plot,
# and the calculated coverage probabilities will be on the y-axis
for(i in 1:length(n.vector)){ #One plot for each sample size
# We use the plot function to plot the for the exact method with a black line
plot(p.vector, cover[,1,i], type="l", # The type="l" parameter connects the points into a line
main=paste0("Coverage Probability for 3 Methods \n n = ", as.character(n.vector[i])), #We add a title to the plot
# We create the character string with paste0 (no spacing between strings) and \n for a line break
xlab="True Probability", ylab="Coverage Probability", ylim=c(0,1)
# We add labels for the plot and set the limits for the y-axis to be between 0 and 1, since these are probabilities
)
# Next we add the asymptotic method, using the points function, as a red dashed line
points(p.vector, cover[,2,i], type="l", lty=2, col="red") #The lty=2 parameter means the line type is a dashed line
# Now we add the continuity corrected method as a green dotted line
points(p.vector, cover[,3,i], type="l", lty=3, col="green") #The lty=3 parameter means the line type is a dotted line
# Lastly we add the legend in the bottom right corner of the plot
# We use the cex parameter to shrink the size of the legend, but we change the size depending on the number of plots
if(length(n.vector) == 1){ #If there is only one plot
legend("bottomright", cex=0.5, lty=1:3, col=c("black", "red", "green"), legend=c("Exact", "Asymptotic", "Continuity Corrected"))
}else{ #If there are multiple plot
legend("bottomright", cex=0.2, lty=1:3, col=c("black", "red", "green"), legend=c("Exact", "Asymptotic", "Continuity Corrected"))
# The user might need to change the window size so that the text in the legend becomes readable
}
}
# This for loop creates one plot for each sample size
}
# Question 1
p.vector <- seq(0.01, 0.50, 0.01) #Each example function call uses the same probabilities
seed <- 1998 #Each example function call uses the same seed
plot.coverage(40, p.vector, seed)
# Question 2
plot.coverage(c(10, 20, 30), p.vector, seed)
# Question 3
plot.coverage(seq(10, 80, 10), p.vector, seed)
# This throws an error, as it should, because it has 8 sample sizes
# Question 4
plot.coverage(c(25, 50, 100, 200), p.vector, seed)
# Matthew Smith, 11/28/18
# BIS 679
# Homework 10, due 11/29
# First we include the coverage function from Notes8.R
######################################################################################################
#Function: coverage
#Author: Denise Esserman
#Creation Date: November 24, 2015 (version 3.2.2)
#Modified: November 06, 2017 (version 3.4.2)
#Purpose: This function calculates the coverage probabilities for a one sample proportion using
#         three methods (1) exact, (2) asymptotic, (3) asymptotic with continuity correction
# Required Parameters:
#      n.vector = a vector of the sample sizes that we want to explore
#      p.vector= a vector of probabilities that we want to explore
#      seed = the seed to start the random number generator
#Optional Parameters:
#      nsims=the number of simulations to conduct - default is 1000
#Libraries: Requires the installation of binom package
#Output: Returns an array with the coverage probabilites.  Each matrix within the array
#represents a given sample size in n.vector.  The rows in the matrix are the probabilities we
#want to explore and the columns represent the 3 methods.
#Example: Calculate the coverage probabilities for two sample sizes and 5 proportions
#coverage(n.vector=c(30,100),p.vector=c(0.1,0.2,0.3,0.4,0.5), seed=121212)
########################################################################################################
coverage<-function(n.vector, p.vector, seed, nsims=1000) {
#check to see if the package is already installed
if (!require("binom")) install.packages("binom")
require(binom) #load the package
# First one: check if there
# Second one: check if installed
set.seed(seed)
#nsims=nsims
y=list(p.vector,c("Exact", "Asymptotic", "Continuity Corrected"), n.vector)
cover.prob<-array(rep(NA, length(p.vector)*3*length(n.vector)),dim=c(length(p.vector),3, length(n.vector)),dimnames=y)
for(j in 1:length(n.vector)) {
for(i in 1:length(p.vector)){
#Get vector of length nsims containing the number of successes from the binomial distribution
# with size n and probability of succcess p
successes<-rbinom(nsims,size=n.vector[j],p=p.vector[i])
#Get the upper and lower bounds of each of the three types of confidence intervals
lower.exact<-binom.confint(successes,n.vector[j],method="exact")$lower
upper.exact<-binom.confint(successes,n.vector[j],method="exact")$upper
lower.asym<-binom.confint(successes,n.vector[j],method="asymptotic")$lower
upper.asym<-binom.confint(successes,n.vector[j],method="asymptotic")$upper
lower.cc<-lower.asym-0.5/n.vector[j]
upper.cc<-upper.asym+0.5/n.vector[j]
cover.prob[i,1,j]<-mean(lower.exact<=p.vector[i] & upper.exact>=p.vector[i])
cover.prob[i,2,j]<-mean(lower.asym<=p.vector[i] & upper.asym>=p.vector[i])
cover.prob[i,3,j]<-mean(lower.cc<=p.vector[i] & upper.cc>=p.vector[i])
}
}
return(cover.prob) #return the array
}
# Next we construct the plot.coverage function and document it
######################################################################################################
# Function: plot.coverage
# Author: Matthew Smith
# Creation Date: November 28, 2018
# Purpose: This function uses the coverage function from class to calculate coverage probabilities
#          using exact, asymptotic, and asymptotic with continuity correction methods, for up to
#          6 different sample sizes. The function then plots (for each sample size) the coverage
#          probability for each real probability, for each method of determining the coverage probability,
#          all in one plot window.
# Required Parameters:
#      n.vector = a vector of the sample sizes that we want to explore
#      p.vector = a vector of probabilities that we want to explore
#      seed = the seed to start the random number generator
# Optional Parameters:
#      nsims = the number of simulations to conduct (default is 1000)
# Libraries: Requires the installation of binom package
# Dependent Functions: Requires the coverage function from class to be loaded
# Output: This function does not return a value but instead creates plots in the plot window. There is
#         one plot for each sample size given. On each plot, the real probabilities for the underlying
#         simulations are on the x-axis, and the calculated coverage probabilities (using each of the
#         3 methods) are on the y-axis. All of the plots are in the same window, and the size of the
#         legends depend on the number of plots. The function throws an error if the user supplies more
#         than 6 sample sizes.
# Example: In this example, we create plots for sample sizes 10, 20, 30, 40, 50, and 60, probabilities
#          ranging from 0.01 to 0.50 by 0.01, and seed 1998.
#          plot.coverage(seq(10,60,10), seq(0.01,0.50,0.01), 1998)
########################################################################################################
plot.coverage <- function(n.vector, p.vector, seed, nsims=1000){ #This uses the same parameters as coverage
# First we format the plot window or throw an error if the user enters too many sample sizes
if(length(n.vector) == 1){
par(mfrow=c(1,1)) #If we only have one sample size, format the plot window for one plot
}else if(length(n.vector) <= 6){
par(mfrow=c(2, ceiling(length(n.vector)/2)))
# If we have a sample size between 2 and 6, we format the plot window with two rows
# We use a ceiling function to set the number of columns so that length(n.vector)=2 gives one column,
# length(n.vector) = 3 or 4 gives 2 columns, and length(n.vector) = 5 or 6 gives 3 columns
}else{ #If there are more than six sample sizes
stop("User entered too many sample sizes. Please enter 6 or fewer.") #Message when error thrown
}
# Now we run the coverage function (which will load the binom package), the output of which we will plot
cover <- coverage(n.vector=n.vector, p.vector=p.vector, seed=seed, nsims=nsims) #Use the parameters from plot.coverage
# This is an array, where each matrix corresponds to a sample size n, each row is a probability p, and
# each column is the coverage probability according to a different method of calculating
# There are length(n.vector) matrices, and we will have a different plot
# The probabilities p will be on the x-axis of each plot,
# and the calculated coverage probabilities will be on the y-axis
for(i in 1:length(n.vector)){ #One plot for each sample size
# We use the plot function to plot the for the exact method with a black line
plot(p.vector, cover[,1,i], type="l", # The type="l" parameter connects the points into a line
main=paste0("Coverage Probability for 3 Methods \n n = ", as.character(n.vector[i])), #We add a title to the plot
# We create the character string with paste0 (no spacing between strings) and \n for a line break
xlab="True Probability", ylab="Coverage Probability", ylim=c(0,1)
# We add labels for the plot and set the limits for the y-axis to be between 0 and 1, since these are probabilities
)
# Next we add the asymptotic method, using the points function, as a red dashed line
points(p.vector, cover[,2,i], type="l", lty=2, col="red") #The lty=2 parameter means the line type is a dashed line
# Now we add the continuity corrected method as a green dotted line
points(p.vector, cover[,3,i], type="l", lty=3, col="green") #The lty=3 parameter means the line type is a dotted line
# Lastly we add the legend in the bottom right corner of the plot
# We use the cex parameter to shrink the size of the legend, but we change the size depending on the number of plots
if(length(n.vector) == 1){ #If there is only one plot
legend("bottomright", cex=0.5, lty=1:3, col=c("black", "red", "green"), legend=c("Exact", "Asymptotic", "Continuity Corrected"))
}else{ #If there are multiple plot
legend("bottomright", cex=0.2, lty=1:3, col=c("black", "red", "green"), legend=c("Exact", "Asymptotic", "Continuity Corrected"))
# The user might need to change the window size so that the text in the legend becomes readable
}
}
# This for loop creates one plot for each sample size
}
# Question 1
p.vector <- seq(0.01, 0.50, 0.01) #Each example function call uses the same probabilities
seed <- 1998 #Each example function call uses the same seed
plot.coverage(40, p.vector, seed)
# Question 2
plot.coverage(c(10, 20, 30), p.vector, seed)
# Question 3
plot.coverage(seq(10, 80, 10), p.vector, seed)
# This throws an error, as it should, because it has 8 sample sizes
# Question 4
plot.coverage(c(25, 50, 100, 200), p.vector, seed)
intersect(c(1,2),c(1,3))
intersect(c(1,2),c(1,3,2))
intersect(c(1,2),c(3,4))
length(intersect(c(1,2),c(3,4)))
rm(list=ls())
a <- sparse.matrix(data.frame(i=c(1,2), j=c(1,1), x=c(3,1)))
setwd("~/Documents/YSPH/YSPH_Year2/BIS_557/bis557/R")
setwd("~/Documents/YSPH/YSPH_Year2/BIS_557/bis557/")
library(devtools)
document()
a <- sparse.matrix(data.frame(i=c(1,2), j=c(1,1), x=c(3,1)))
b <- sparse.matrix(data.frame(i=c(1,2,3), j=c(1,1,2), x=c(4.4,1.2,3)))
c <- sparse.matrix(data.frame(i=integer(), j=integer(), x=double()))
i <- 1, j <- 1
i <- 1; j <- 1
a_i <- a[which(a$i==i),]
b_j <- b[which(b$j==j),]
k_vector <- intersect(a_i$j, b_j$i)
k_vector
a
b
k <- c(1,2)
c(1,3) in k
rm(k)
a_i
row.names(a_i) <- a_i$j
a_i
a_i$x[k_vector]
b_j
row.names(b_j) <- a_j$i
row.names(b_j) <- b_j$i
b_j
b_j$x[names==k_vecto]
b_j$x[names==k_vector]
b_j$x[names=k_vector]
b_j$i[2] <- 3
b_j
b_j$x[names=k_vector]
rm(list=ls())
document()
a <- sparse.matrix(data.frame(i=c(1,2), j=c(1,1), x=c(3,1)))
b <- sparse.matrix(data.frame(i=c(1,2,3), j=c(1,1,2), x=c(4.4,1.2,3)))
a %*% b
`%*%.sparse.matrix`(a,b)
document()
`%*%.sparse.matrix`(a,b)
a
b
b %*% a
`%*%.sparse.matrix`(b,a)
t(a)
a
a`%*%`b
a%*%b
`%*%`(b,a)
document()
`%*%`(b,a)
`%*%.sparse.matrix`(b,a)
k_vector
i
j
a_i
b_j
c_new
i
j
q
q
q
a + a
`%*%.sparse.matrix`(b,a)
i
j
a_i
b_j
c_new
i
j
a_i
b_j
c_new
a_i$x
b_j$x
b_j$x[names=k_vector]
as.matrix(3) %*% as.matrix(1)
k_vector
a_i$x[names=k_vetor]
a_i$x[names=k_vector]
names(a_i$x)
?row.names
q
document()
`%*%.sparse.matrix`(b,a)
document()
`%*%.sparse.matrix`(b,a)
document()
`%*%.sparse.matrix`(b,a)
k_vector
i
j
a_i
b_j
a_i$x[row.names=k_vector]
a_i$x[row.names==k_vector]
a_i$x[row.names=k_vector]
k_vector
row.names(a_i$x)
row.names(a_i)
class(a_i$x)
row.names(a_i$x)
a_i$x[drop=FALSE]
row.names(a_i$x[drop=FALSE])
a_i[names=k_vector,]
a_i[as.character(k_vector),]
as.matrix(a_i[as.character(k_vector),"x"]) %*% as.matrix(b_j[as.character(k_vector),"x"])
as.numeric(as.matrix(a_i[as.character(k_vector),"x"]) %*% as.matrix(b_j[as.character(k_vector),"x"]))
document()
`%*%.sparse.matrix`(b,a)
document()
`%*%.sparse.matrix`(b,a)
colnames(a)
document()
`%*%.sparse.matrix`(b,a)
row.names(`%*%.sparse.matrix`(b,a))
document()
`%*%.sparse.matrix`(b,a)
row.names(`%*%.sparse.matrix`(b,a))
rownames(`%*%.sparse.matrix`(b,a))
rownames(`%*%.sparse.matrix`(b,a))[1]
document()
rownames(`%*%.sparse.matrix`(b,a))
row.names(`%*%.sparse.matrix`(b,a))
document()
row.names(`%*%.sparse.matrix`(b,a))
a
row.names(a)
document()
row.names(`%*%.sparse.matrix`(b,a))
colnames(`%*%.sparse.matrix`(b,a))
document()
colnames(`%*%.sparse.matrix`(b,a))
document()
colnames(`%*%.sparse.matrix`(b,a))
document()
colnames(`%*%.sparse.matrix`(b,a))
document()
%*%(b,a)
b %*% a
`%*%.sparse.matrix`(b,a)
a + a
b + b
?`%*%`
b %*% a
class(b)
`%*%` <- function(a,b){UseMethod("%*%",a)}
b %*% a
a
b
a + b
document()
rm(list=ls())
a <- sparse.matrix(data.frame(i=c(1,2), j=c(1,1), x=c(3,1)))
b <- sparse.matrix(data.frame(i=c(1,2,3), j=c(1,1,2), x=c(4.4,1.2,3)))
b %*% a
document()
b %*% a
document()
b %*% a
`%*%.sparse.matrix`(b, a)
document()
b %*% a
document()
document()
b %*% a
`%*%` <- function(a, b){
UseMethod("%*%", a)
}
b %*% a
document()
b %*% a
document()
rm(`%*%`)
b %*% a
`%*%` <- function(a, b){
UseMethod("%*%", a)
}
b %*% a
max(1:10)
rm(list=ls())
document()
a <- sparse.matrix(i=c(1,2), j=(1,1), x=c(3,1))
a <- sparse.matrix(i=c(1,2), j=c(1,1), x=c(3,1))
a
a$entries
document()
View(a)
a <- sparse.matrix(i=c(1,2), j=c(1,1), x=c(3,1), dims=c(3,2))
b <- sparse.matrix(i=c(1,2,3), j=c(1,1,2), x=c(4.4,1.2,3))
a + b
document()
a + b
document()
document()
a + b
sum(c(1,2) != c(1,2))
sum(c(1,2) != c(1,3))
document()
a + b
document()
b %*% a
`%*%` <- function(a, b){
UseMethod("%*%", a)
}
b %*% a
a$dims
a$dims <- c(2,1)
b %*% a
document()
b %*% a
a$entries$i
document()
b %*% a
document()
b %*% a
document()
a
t(a)
document()
