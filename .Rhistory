ret$coeficients <- rnorm(3)
ret
names(ret)
class(ret)
class(ret) <- "lm"
ret
ret$coefficients <- rnorm(3)
ret
class(ret)
ncol(model.matrix(form))
ncol(model.matrix(form,iris))
form
df <- data.frame(x1=(1,1,1),x2=(2,2,3))
df <- data.frame(x1=c(1,1,1),x2=c(2,2,3))
model.matrix(form,df)
?model.matrix
df$y <- c(3,4,5)
model.matrix(form,df)
ncol(model.matrix(form,df))
colnames(model.matrix(form,df))
df
a <- c(TRUE, FALSE)
b <- c(TRUE, TRUE)
a && b
a & b
a || b
a | b
rm(list=ls())
as.numeric(" 90 ")
as.numeric(" 90 ") == 90
as.numeric(" 90") == 90
as.numeric("90 ") == 90
library(faraway)
data(pima)
pima$bmi
plot(density(pima$bmi))
summary(pima$bmi)
NA < 0
summary(pima)
1 in 1:10
i in 1:10
?IN
x <- seq(1,40)
X
x
y <- x
seq(1,39,2)
y[seq(1,39,2)] <- NA
y
sum(y)
is.na(y)
z <- y[is.na(y)]
z
z <- y[!is.na(y)]
z
sum(z)
rm(x,y,z)
x <- rnorm(0,1,40)
x
?rnorm
x <- rnorm(40, 0, 1)
x
sum(x[seq(2,40,2)])
sample(1:3)
?sample
sample(1:3,size=1)
sample(1:3,size=1)
sample(1:3,size=1)
sample(1:3,size=1)
sample(1:3,size=1)
sample(1:4)
sample(1:4, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
sample(1:4, size=1, replace=TRUE)
?rnorm
pnorm(0)
pnorm(1, sd=1)
2*pnorm(-0.86)
2*pnorm(0.15)
2*pnorm(2.21)
2*pnorm(0.15, lower.tail=FALSE)
2*pnorm(2.21, lower.tail=FALSE)
2*pnorm(0.84, lower.tail=FALSE)
qnorm(0.40)
qnorm(0.20)
qnorm(1-0.80/2, lower.tail=FALSE)
qnorm((1-0.80/2), lower.tail=FALSE)
qnorm((1-0.80)/2, lower.tail=FALSE)
qnorm((1-0.80)/2, lower.tail=TRUE)
qnorm((1-0.80)/2, lower.tail=FALSE)
qnorm((1-0.50)/2, lower.tail=FALSE)
qnorm((1-0.26)/2, lower.tail=FALSE)
qnorm((1-0.90)/2, lower.tail=FALSE)
dr <- data.frame(X=rnorm(10))
dr
dr$diff <- dr$X - mean(dr$X)
dr
mean(dr$X)
ls()
rm(list=ls())
q()
ls()
q()
\
poly(1:2,1)
poly(1:2,1)$coefs
crossprod(poly(1:2,1))
crossprod(poly(1:2,2))
crossprod(poly(1:3,2))
poly(1:3,2)
?qnorm
1-0.14
1-0.07
1-0.03
/86
1644.191/86
20*86
86*19
1720/86
sqrt(0.9)
0.95^2
h
977*3
library(bis557)
library(glmnet) #For the glmnet function
break_kkt
b
library(bis557)
library(glmnet) #For the glmnet function
break_kkt
library(bis557)
library(glmnet) #For the glmnet function
break_kkt
library(bis557)
library(glmnet) #For the glmnet function
break_kkt
setwd("~/Documents/YSPH/YSPH_Year2/BIS_557/bis557/vignettes")
setwd("~/Documents/YSPH/YSPH_Year2/BIS_557/bis557/")
library(bis557)
library(glmnet) #For the glmnet function
break_kkt
library(bis557)
library(glmnet) #For the glmnet function
document()
library(bis557)
library(glmnet) #For the glmnet function
devtools::document()
break_kkt
X <- model.matrix(Sepal.Length ~ ., iris)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X_stand, iris$Sepal.Length, lambda)
b
as.matrix(b)
X
X_stand
X
scale(X)
break_kkt
document()
library(devtools)
document()
X <- model.matrix(Sepal.Length ~ ., iris)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X_stand, iris$Sepal.Length, lambda)
b
ret
::s
test_var / lambda
lambda
test_var
X <- model.matrix(Sepal.Length ~ ., iris)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X_stand, iris$Sepal.Length, lambda)
test_var
test_var
lambda
X_stand[,j] * (y - X_stand %*% b)
X_stand[,1]
test_var
j
devtools::document()
X <- model.matrix(Sepal.Length ~ . -1, iris)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X_stand, iris$Sepal.Length, lambda)
b
b$Petal.Length <- 0 #This was originally non-zero
break_kkt(b_updated, X_stand, iris$Sepal.Length, lambda)
X <- model.matrix(Sepal.Length ~ . -1, iris)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X_stand, iris$Sepal.Length, lambda)
devtools::document()
X <- model.matrix(Sepal.Length ~ . -1, iris)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X_stand, iris$Sepal.Length, lambda)
test_var
test_var/lambda
b
j
test_var / lambda
u
b{j]}
b[j]}
b[j]
test_var / lambda
ret[j]
ret
ret
ret
test_var / lambda
X <- model.matrix(Sepal.Length ~ . -1, iris)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X_stand, iris$Sepal.Length, lambda)
document()
X <- model.matrix(Sepal.Length ~ . -1, iris)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X_stand, iris$Sepal.Length, lambda)
c
document()
X <- model.matrix(Sepal.Length ~ . -1, iris)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X_stand, iris$Sepal.Length, lambda)
X <- model.matrix(Sepal.Length ~ . -1, iris)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X_stand, iris$Sepal.Length, lambda)
document()
X <- model.matrix(Sepal.Length ~ . -1, iris)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X_stand, iris$Sepal.Length, lambda)
test_var
test_var/lambda
resids <- y - X %*% b
resids <- y - X_stand %*% b
resids
iris$Sepal.Length
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X, iris$Sepal.Length, lambda)
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X, iris$Sepal.Length, lambda)
resids <- y - X_stand %*% b
resids
y
b
X_stand
X_stand %*% b
X_stand %*% b
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X, iris$Sepal.Length - mean(iris$Sepal.Length), lambda)
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X, iris$Sepal.Length - mean(iris$Sepal.Length), lambda)
test_var
lambda
test_var / lambda
resids <- y - X_stand %*% b
resids
mys <- apply(X_scale, 2, function(xj) crossprod(xj, resids)) / lamda / nrow(X_scale)
mys <- apply(X_stand, 2, function(xj) crossprod(xj, resids)) / lamda / nrow(X_stand)
mys <- apply(X_stand, 2, function(xj) crossprod(xj, resids)) / lambda / nrow(X_stand)
mys
b
round(mys, 2)
round(mys, 1)
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
iris$Sepal.Length <- iris$Sepal.Length - mean(iris$Sepal.Length)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X, iris$Sepal.Length, lambda)
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
iris$Sepal.Length <- iris$Sepal.Length - mean(iris$Sepal.Length)
plot(cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)) #Get an estimate for the optimal lambda
lambda <- exp(-4.5) #Based on the above plot, after exponentiating
b <- glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X, iris$Sepal.Length, lambda)
resids <- y - X_stand %*% b
resids
y
mean(y)
mys <- apply(X_stand, 2, function(xj) crossprod(xj, resids)) / nrow(X_stand) / lambda
mys
round(mys, 2)
round(mys, 1)
?glmnet
fit <- cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
iris$Sepal.Length <- iris$Sepal.Length - mean(iris$Sepal.Length)
fit <- cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)
plot(fit) #Get an estimate for the optimal lambda
lambda <- fit$lambda.min #Based on the above plot, after exponentiating
b <- fit$glmnet.fit$beta[,fit$lambda == fit$lambda.min]
#  glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X, iris$Sepal.Length, lambda)
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
iris$Sepal.Length <- iris$Sepal.Length - mean(iris$Sepal.Length)
fit <- cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)
plot(fit) #Get an estimate for the optimal lambda
lambda <- fit$lambda.min #Based on the above plot, after exponentiating
b <- fit$glmnet.fit$beta[,fit$lambda == fit$lambda.min]
#  glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X, iris$Sepal.Length, lambda)
document()
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
iris$Sepal.Length <- iris$Sepal.Length - mean(iris$Sepal.Length)
fit <- cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)
plot(fit) #Get an estimate for the optimal lambda
lambda <- fit$lambda.min #Based on the above plot, after exponentiating
b <- fit$glmnet.fit$beta[,fit$lambda == fit$lambda.min]
#  glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
break_kkt(b, X, iris$Sepal.Length, lambda)
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
iris$Sepal.Length <- iris$Sepal.Length - mean(iris$Sepal.Length)
fit <- cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)
plot(fit) #Get an estimate for the optimal lambda
lambda <- fit$lambda.min #Based on the above plot, after exponentiating
b <- fit$glmnet.fit$beta[,fit$lambda == fit$lambda.min]
#  glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
document()
break_kkt(b, X, iris$Sepal.Length, lambda)
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
iris$Sepal.Length <- iris$Sepal.Length - mean(iris$Sepal.Length)
fit <- cv.glmnet(X, iris$Sepal.Length, standardize=TRUE)
plot(fit) #Get an estimate for the optimal lambda
lambda <- fit$lambda.min #Based on the above plot, after exponentiating
b <- fit$glmnet.fit$beta[,fit$lambda == fit$lambda.min]
#  glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
document()
break_kkt(b, X, iris$Sepal.Length, lambda)
mys
b
b
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
iris$Sepal.Length <- iris$Sepal.Length - mean(iris$Sepal.Length)
fit <- cv.glmnet(X, iris$Sepal.Length, standardize=FALSE, intercept = FALSE)
plot(fit) #Get an estimate for the optimal lambda
lambda <- fit$lambda.min #Based on the above plot, after exponentiating
b <- fit$glmnet.fit$beta[,fit$lambda == fit$lambda.min]
#  glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
document()
break_kkt(b, X, iris$Sepal.Length, lambda)
mys
lambda
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
iris$Sepal.Length <- iris$Sepal.Length - mean(iris$Sepal.Length)
fit <- cv.glmnet(X, iris$Sepal.Length, standardize=FALSE, intercept = FALSE)
plot(fit) #Get an estimate for the optimal lambda
lambda <- fit$lambda.min #Based on the above plot, after exponentiating
b <- fit$glmnet.fit$beta[,fit$lambda == fit$lambda.min]
#  glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
document()
break_kkt(b, X, iris$Sepal.Length, lambda)
mys <- apply(X_stand, 2, function(xj) crossprod(xj, resids)) / exp(lambda) / nrow(X_stand)
mys
lamda
lambda
mys <- apply(X_stand, 2, function(xj) crossprod(xj, resids)) / lambda / nrow(X_stand)
mys
round(mys, 2)
round(mys, 1)
(b == 0) & abs(mys >= 1)
mys
round(mys, 1)
?glmnet
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
iris$Sepal.Length <- iris$Sepal.Length - mean(iris$Sepal.Length)
fit <- cv.glmnet(X, iris$Sepal.Length, standardize=FALSE, intercept = FALSE)
plot(fit) #Get an estimate for the optimal lambda
lambda <- fit$lambda.min #Based on the above plot, after exponentiating
b <- fit$glmnet.fit$beta[,fit$lambda == fit$lambda.min]
#  glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
#b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
document()
break_kkt(b, X, iris$Sepal.Length, lambda)
mys
X <- model.matrix(Sepal.Length ~ . -1, iris)
X <- scale(X)
iris$Sepal.Length <- iris$Sepal.Length - mean(iris$Sepal.Length)
fit <- cv.glmnet(X, iris$Sepal.Length, standardize=FALSE, intercept = FALSE)
plot(fit) #Get an estimate for the optimal lambda
lambda <- fit$lambda.min #Based on the above plot, after exponentiating
b <- fit$glmnet.fit$beta[,fit$lambda == fit$lambda.min]
#  glmnet(X, iris$Sepal.Length, lambda=lambda, standardize=TRUE)$beta
#b <- as.matrix(b)
#X_stand <- scale(X) #Standardize the data matrix X before plugging it into this function
document()
break_kkt(b, X, iris$Sepal.Length, lambda)
mys
round(mys, 1)
round(mys, 0)
lambda
build_vignettes()
c
c
c
cc
c
build_vignettes()
document()
